"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SMS = void 0;
const server_client_1 = require("@vonage/server-client");
const classes_1 = require("./classes");
const enums_1 = require("./enums");
const crypto_1 = __importDefault(require("crypto"));
const auth_1 = require("@vonage/auth");
/**
 * Client for sending legacy SMS messages using the Vonage API.
 *
 * @example
 * Create a standalone SMS client
 *
 * ```ts
 * import { AlgorithmTypes } from '@vonage/auth';
 * import { SMS } from '@vonage/sms';
 *
 * const smsClient = new SMS({
 *  apiKey: VONAGE_API_KEY,
 *  apiSecret: VONAGE_API_SECRET
 *  secret: {
 *    secret: VONAGE_SIGNATURE_SECRET
 *    algorithm: AlgorithmTypes.sha512hmac
 *  },
 * });
 * ```
 *
 * @example
 * Create an SMS client from the Vonage client
 *
 * ```ts
 * import { AlgorithmTypes } from '@vonage/auth';
 * import { Vonage } from '@vonage/server-client';
 *
 * const vonage = new Vonage({
 *   apiKey: VONAGE_API_KEY,
 *   apiSecret: VONAGE_API_SECRET
 *   secret: {
 *     secret: VONAGE_SIGNATURE_SECRET
 *     algorithm: AlgorithmTypes.sha512hmac
 *   },
 * });
 *
 * const smsClient = vonage.sms;
 * ```
 */
class SMS extends server_client_1.Client {
    constructor() {
        super(...arguments);
        this.authType = server_client_1.AuthenticationType.KEY_SECRET;
    }
    /**
     * Sends an SMS message using the legacy Vonage SMS API.
     *
     * @param {SMSParams} [params] - The parameters for the SMS message.
     * @return {Promise<SMSMessages>} A Promise that resolves to the response containing details about the sent SMS messages.
     * @throws {MessageSendAllFailure} If all SMS messages fail to send.
     * @throws {MessageSendPartialFailure} If some SMS messages fail to send.
     * @example
     *
     * ```ts
     * const response = await smsClient.send({
     *   to: TO_NUMBER,
     *   from: FROM_NUMBER,
     *   text: 'Hello from Vonage SMS API',
     * });
     * console.log(`Number of messages sent: ${response.messageCount}`););
     * ```
     */
    async send(params) {
        const resp = await this.sendPostRequest(`${this.config.restHost}/sms/json`, server_client_1.Client.transformers.kebabCaseObjectKeys(params || {}));
        const messageData = server_client_1.Client.transformers.camelCaseObjectKeys(resp.data, true, true);
        const totalMessages = messageData.messageCount || 0;
        const messages = messageData.messages || [];
        const failures = messages.reduce((failures, { status }) => status !== enums_1.SMSStatus.SUCCESS ? failures + 1 : failures, 0);
        if (failures < 1) {
            return messageData;
        }
        if (failures === totalMessages) {
            throw new classes_1.MessageSendAllFailure(messageData);
        }
        throw new classes_1.MessageSendPartialFailure(messageData);
    }
    /**
     * Verifies the signature of a request using the specified algorithm and signature secret.
     *
     * @remarks
     * This will not parse the request parameters from the request object, so you will need to do that yourself.
     *
     * @param {string} signature - The signature to be verified.
     * @param {Record<string, string>} params - The request parameters used to generate the signature.
     * @param {string} signatureSecret - The secret key used for generating the signature.
     * @param {AlgorithmTypes} algorithm - The algorithm used for generating the signature.
     * @return {boolean} `true` if the signature is valid, `false` otherwise.
     * @throws {Error} If the provided signature algorithm is not supported.
     *
     * @example
     * ```ts
     * const params = Object.assign(request.query, request.body);
     * const { sig } = params;
     *
     * sms.verifySignature(
     *   sig,
     *   {}, // request parameters
     *   VONAGE_API_SIGNATURE_SECRET,
     *   AlgorithmTypes.md5hash,
     * ) === params.sig) {
     *   console.log("Valid signature");
     * } else {
     *   console.log("Invalid signature");
     * }
     * ```
     */
    verifySignature(signature, params, signatureSecret, algorithm) {
        params = params || {};
        let signedQuery = '';
        params = JSON.parse(JSON.stringify(params));
        if (params.sig) {
            delete params.sig;
        }
        Object.keys(params)
            .sort()
            .forEach((key) => {
            // replace & and = with _
            signedQuery += '&' + key + '=' + params[key].replace(/[&=]/g, '_');
        });
        const hashMap = {};
        hashMap[auth_1.AlgorithmTypes.md5hmac] = 'md5';
        hashMap[auth_1.AlgorithmTypes.sha1hmac] = 'sha1';
        hashMap[auth_1.AlgorithmTypes.sha256hmac] = 'sha256';
        hashMap[auth_1.AlgorithmTypes.sha512hmac] = 'sha512';
        let hash = '';
        switch (algorithm) {
            case auth_1.AlgorithmTypes.md5hash:
                signedQuery += signatureSecret;
                hash = crypto_1.default.createHash('md5').update(signedQuery).digest('hex');
                break;
            case auth_1.AlgorithmTypes.md5hmac:
            case auth_1.AlgorithmTypes.sha1hmac:
            case auth_1.AlgorithmTypes.sha256hmac:
            case auth_1.AlgorithmTypes.sha512hmac:
                hash = crypto_1.default
                    .createHmac(hashMap[algorithm], signatureSecret)
                    .update(signedQuery)
                    .digest('hex');
                break;
            default:
                throw new Error(`Unknown signature algorithm: ${algorithm}. Expected: md5hash, md5, sha1, sha256, or sha512`);
        }
        return signature.toUpperCase() === hash.toUpperCase();
    }
}
exports.SMS = SMS;
