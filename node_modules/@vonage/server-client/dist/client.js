"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const node_fetch_2 = __importDefault(require("node-fetch"));
const auth_1 = require("@vonage/auth");
const vetch_1 = require("@vonage/vetch");
const enums_1 = require("./enums");
const transfomers = __importStar(require("./transformers"));
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('vonage:server-client');
class Client {
    /**
     * Creates a new instance of the Client.
     *
     * @param {AuthInterface | AuthParams} credentials - The authentication credentials or an authentication instance.
     * @param {ConfigParams} [options] - Optional configuration settings for the client.
     */
    constructor(credentials, options) {
        /**
         * The type of authentication used for the client's requests.
         */
        this.authType = enums_1.AuthenticationType.QUERY_KEY_SECRET;
        this.auth = !Object.prototype.hasOwnProperty.call(credentials, 'getQueryParams')
            ? new auth_1.Auth(credentials)
            : credentials;
        this.config = {
            restHost: options?.restHost || 'https://rest.nexmo.com',
            apiHost: options?.apiHost || 'https://api.nexmo.com',
            videoHost: options?.videoHost || 'https://video.api.vonage.com',
            meetingsHost: options?.meetingsHost || 'https://api-eu.vonage.com',
            proactiveHost: options?.proactiveHost || 'https://api-eu.vonage.com',
            responseType: options?.responseType || vetch_1.ResponseTypes.json,
            timeout: options?.timeout || null,
        };
    }
    /**
     * Adds the appropriate authentication headers or parameters to the request based on the authentication type.
     *
     * @param {VetchOptions} request - The request options to which authentication needs to be added.
     * @return {Promise<VetchOptions>} - The request options with the added authentication.
     */
    async addAuthenticationToRequest(request) {
        log(`adding ${this.authType || 'api key/secret'} to request`);
        if (!Object.values(enums_1.AuthenticationType).includes(this.authType)) {
            throw new Error('No authentication type set');
        }
        switch (this.authType) {
            case enums_1.AuthenticationType.BASIC:
                request.headers = Object.assign({}, request.headers, {
                    Authorization: await this.auth.createBasicHeader(),
                });
                return request;
            case enums_1.AuthenticationType.JWT:
                request.headers = Object.assign({}, request.headers, {
                    Authorization: await this.auth.createBearerHeader(),
                });
                return request;
        }
        if (this.authType === enums_1.AuthenticationType.QUERY_KEY_SECRET) {
            log(`adding parameters to query string`);
            request.params = {
                ...(request.params ? request.params : {}),
                ...(await this.auth.getQueryParams({})),
            };
            return request;
        }
        if (typeof request.data === 'string') {
            throw new Error('Cannot append auth parameters to body');
        }
        const authParams = await this.auth.getQueryParams({});
        request.data = request.data ?? {};
        // JSON as default
        log(`Adding parameters to body`);
        request.data = {
            ...request.data,
            ...authParams,
        };
        return request;
    }
    /**
     * Sends a DELETE request to the specified URL.
     *
     * @param {string} url - The URL endpoint for the DELETE request.
     * @return {Promise<VetchResponse<T>>} - The response from the DELETE request.
     */
    async sendDeleteRequest(url) {
        const request = {
            url,
            method: vetch_1.HTTPMethods.DELETE,
        };
        return await this.sendRequest(request);
    }
    /**
     * Sends a POST request with form data to the specified URL.
     *
     * @param {string} url - The URL endpoint for the POST request.
     * @param {Record<string, string>} [payload] - Optional payload containing form data to send with the POST request.
     * @return {Promise<VetchResponse<T>>} - The response from the POST request.
     */
    async sendFormSubmitRequest(url, payload) {
        const request = {
            url,
            method: vetch_1.HTTPMethods.POST,
            type: vetch_1.ContentType.FORM_URLENCODED,
            headers: { Accept: 'application/json' },
            ...(payload ? { data: payload } : {}),
        };
        return await this.sendRequest(request);
    }
    /**
     * Sends a GET request to the specified URL with optional query parameters.
     *
     * @param {string} url - The URL endpoint for the GET request.
     * @param {Record<string, unknown>} [queryParams] - Optional query parameters to append to the URL. These should be compatible with Node's URLSearchParams.
     * @return {Promise<VetchResponse<T>>} - The response from the GET request.
     */
    async sendGetRequest(url, queryParams) {
        const request = {
            url,
            method: vetch_1.HTTPMethods.GET,
            ...(queryParams ? { params: queryParams } : {}),
        };
        return await this.sendRequest(request);
    }
    /**
     * Sends a PATCH request to the specified URL with an optional payload.
     *
     * @param {string} url - The URL endpoint for the PATCH request.
     * @param {Record<string, unknown>} [payload] - Optional payload to be sent as the body of the PATCH request.
     * @return {Promise<VetchResponse<T>>} - The response from the PATCH request.
     */
    async sendPatchRequest(url, payload) {
        return this.sendRequestWithData(vetch_1.HTTPMethods.PATCH, url, payload);
    }
    /**
     * Sends a POST request to the specified URL with an optional payload.
     *
     * @param {string} url - The URL endpoint for the POST request.
     * @param {Record<string, unknown>} [payload] - Optional payload to be sent as the body of the POST request.
     * @return {Promise<VetchResponse<T>>} - The response from the POST request.
     */
    async sendPostRequest(url, payload) {
        return this.sendRequestWithData(vetch_1.HTTPMethods.POST, url, payload);
    }
    /**
     * Sends a PUT request to the specified URL with an optional payload.
     *
     * @param {string} url - The URL endpoint for the PUT request.
     * @param {Record<string, unknown>} [payload] - Optional payload to be sent as the body of the PUT request.
     * @return {Promise<VetchResponse<T>>} - The response from the PUT request.
     */
    sendPutRequest(url, payload) {
        return this.sendRequestWithData(vetch_1.HTTPMethods.PUT, url, payload);
    }
    /**
     * Sends a request with JSON-encoded data to the specified URL using the provided HTTP method.
     *
     * @param {HTTPMethods.POST | HTTPMethods.PATCH | HTTPMethods.PUT} method - The HTTP method to be used for the request (only POST, PATCH, or PUT are acceptable).
     * @param {string} url - The URL endpoint for the request.
     * @param {Record<string, unknown>} [payload] - Optional payload to be sent as the body of the request, JSON-encoded.
     * @return {Promise<VetchResponse<T>>} - The response from the request.
     */
    async sendRequestWithData(method, url, payload) {
        const request = {
            url,
            method: method,
            type: vetch_1.ContentType.JSON,
            ...(payload ? { data: payload } : {}),
        };
        return await this.sendRequest(request);
    }
    /**
     * Sends a request adding necessary headers, handling authentication, and parsing the response.
     *
     * @param {VetchOptions} request - The options defining the request, including URL, method, headers, and data.
     * @return {Promise<VetchResponse<T>>} - The parsed response from the request.
     */
    async sendRequest(request) {
        const timeout = request.timeout || this.config.timeout;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, timeout);
        try {
            log('Preparing request', request);
            request = await this.prepareRequest(request);
            const fetcRequest = {
                url: request.url,
                method: request.method,
                headers: request.headers,
                body: this.prepareBody(request),
                ...(timeout ? { signal: controller.signal } : {}),
            };
            log('Sending request', fetcRequest);
            return await this.parseResponse(request, await (0, node_fetch_1.default)(request.url, fetcRequest));
        }
        catch (error) {
            if (error instanceof node_fetch_2.default) {
                log(`Request timed out after ${timeout}`);
            }
            throw error;
        }
        finally {
            clearTimeout(timeoutId);
        }
    }
    /**
     * Prepares the request with necessary headers, authentication, and query parameters.
     *
     * @param {VetchOptions} request - The initial request options.
     * @return {Promise<VetchOptions>} - The modified request options.
     */
    async prepareRequest(request) {
        request.headers = {
            ...request.headers,
            'user-agent': [
                `@vonage/server-sdk/3.0.0`,
                ` node/${process.version.replace('v', '')}`,
                this.config.appendUserAgent ? ` ${this.config.appendUserAgent}` : '',
            ].join(),
        };
        switch (request.type) {
            case vetch_1.ContentType.FORM_URLENCODED:
                request.headers['content-type'] = vetch_1.ContentType.FORM_URLENCODED;
                break;
            case vetch_1.ContentType.JSON:
                request.headers['content-type'] = vetch_1.ContentType.JSON;
                break;
        }
        request = await this.addAuthenticationToRequest(request);
        const url = new URL(request.url);
        const params = new URLSearchParams(request.params);
        // copy params into the URL
        for (const [param, value] of params.entries()) {
            url.searchParams.append(param, value);
        }
        request.url = url.toString();
        return request;
    }
    /**
     * Prepares the body for the request based on the content type.
     *
     * @param {VetchOptions} request - The request options.
     * @return {string | undefined} - The prepared request body as a string or undefined.
     */
    prepareBody(request) {
        request.headers = {
            ...request?.headers,
        };
        if (!request.data) {
            return;
        }
        if (request.type === vetch_1.ContentType.JSON) {
            return JSON.stringify(request.data);
        }
        if (request.type === vetch_1.ContentType.FORM_URLENCODED) {
            const requestParams = new URLSearchParams(request.data);
            requestParams.sort();
            return requestParams.toString();
        }
        return undefined;
    }
    /**
     * Parses the response based on its content type.
     *
     * @template T - The expected type of the parsed response data.
     *
     * @param {VetchOptions} request - The request options.
     * @param {Response} response - The raw response from the request.
     * @return {Promise<VetchResponse<T>>} - The parsed response.
     */
    async parseResponse(request, response) {
        let decoded = null;
        if (!response.ok) {
            log('Request failed', response);
            throw new vetch_1.VetchError(`Request failed with status code ${response.status}`, request, response);
        }
        log('Request succeeded');
        // eslint-disable-next-line max-len
        const [contentType] = (response.headers.get('content-type') || '').split(';');
        log(`Response content type: ${contentType}`);
        switch (contentType) {
            case vetch_1.ContentType.FORM_URLENCODED:
                log('Decoding form data');
                decoded = response.body
                    ? new URLSearchParams(await response.text())
                    : '';
                break;
            case vetch_1.ContentType.JSON:
                log('Decoding JSON');
                decoded = await response.json();
                break;
            default:
                log('Decoding text');
                decoded = await response.text();
        }
        log('Decoded body', decoded);
        const responseHeaders = {};
        for (const [header, value] of response.headers.entries()) {
            Object.assign(response, header, value);
        }
        const result = {
            data: decoded,
            config: request,
            status: response.status,
            statusText: response.statusText,
            headers: responseHeaders,
            request: request,
        };
        log('Response', JSON.stringify(result, null, 2));
        return result;
    }
}
exports.Client = Client;
/**
 * Static property containing utility transformers.
 */
Client.transformers = transfomers;
