"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Numbers = void 0;
const server_client_1 = require("@vonage/server-client");
const enums_1 = require("./enums");
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const buildSearch = ({ endsWith, startsWith, contains, searchPattern, pattern, country, }) => {
    searchPattern = searchPattern ?? enums_1.SearchPattern.CONTAINS;
    if (pattern) {
        return {
            search_pattern: searchPattern,
            pattern: pattern,
            country: country,
        };
    }
    // order of precedent contains, endsWith, startsWith
    if (contains) {
        return {
            search_pattern: enums_1.SearchPattern.CONTAINS,
            pattern: contains,
            country: country,
        };
    }
    if (endsWith) {
        return {
            search_pattern: enums_1.SearchPattern.ENDS_WITH,
            pattern: endsWith,
            country: country,
        };
    }
    if (startsWith) {
        return {
            search_pattern: enums_1.SearchPattern.START_WITH,
            pattern: startsWith,
            country: country,
        };
    }
    return {};
};
const sortFeatures = (features) => {
    // API expects these as a CSV in a specific order
    if (features.length > 4) {
        throw new Error('Invalid number of features request');
    }
    if (features.length === 1) {
        return features.join();
    }
    if (features.length === 3) {
        return [enums_1.Feature.SMS, enums_1.Feature.MMS, enums_1.Feature.VOICE].join(',');
    }
    const newOrder = [];
    if (features.includes(enums_1.Feature.SMS)) {
        newOrder.push(enums_1.Feature.SMS);
    }
    if (features.includes(enums_1.Feature.VOICE)) {
        newOrder.push(enums_1.Feature.VOICE);
    }
    if (features.includes(enums_1.Feature.MMS)) {
        newOrder.push(enums_1.Feature.MMS);
    }
    return newOrder.join(',');
};
/**
 * Client for buying, canceling, and searching for phone numbers.
 *
 * @example
 * Create a standalone Numbers client
 *
 * ```ts
 * import { Numbers } from '@vonage/numbers';
 *
 * const numbersClient = new Numbers({
 *  apiKey: VONAGE_API_KEY,
 *  apiSecret: VONAGE_API_SECRET
 * });
 * ```
 *
 * @example
 * Create an Numbers client from the Vonage client
 *
 * ```ts
 * import { Vonage } from '@vonage/server-client';
 *
 * const vonage = new Vonage({
 *   apiKey: VONAGE_API_KEY,
 *   apiSecret: VONAGE_API_SECRET
 * });
 *
 * const numbersClient = vonage.numbers;
 * ```
 */
class Numbers extends server_client_1.Client {
    constructor() {
        super(...arguments);
        this.authType = server_client_1.AuthenticationType.QUERY_KEY_SECRET;
    }
    /**
     * Buy a phone number.
     *
     * @param {NumbersParams} params - The parameters for buying a number.
     * @return {Promise<NumbersEmptyResponse>} A promise that resolves to an empty response or an error response.
     *
     * @example
     * Buy a phone number
     * ```ts
     * import { Country } from '@vonage/numbers';
     * const resp = await numbersClient.buyNumber({
     *   country: Country.US,
     *   msisdn: '15555555555'
     * });
     *
     * if (resp.errorCode) {
     *   console.log(`Error: ${resp.errorCodeLabel}`);
     * } else {
     *   console.log('Number bought successfully');
     * }
     * ```
     */
    async buyNumber(params) {
        const resp = await this.sendFormSubmitRequest(`${this.config.restHost}/number/buy`, server_client_1.Client.transformers.snakeCaseObjectKeys(params));
        return {
            errorCode: `${resp.data['error-code']}`,
            errorCodeLabel: resp.data['error-code-label'],
        };
    }
    /**
     * Cancel a phone number.
     *
     * @param {NumbersParams} params - The parameters for canceling a number.
     * @return {Promise<NumbersEmptyResponse>} A promise that resolves to an empty response or an error response.
     *
     * @example
     * Cancel a phone number
     *
     * ```ts
     *
     * const resp = await numbersClient.cancelNumber({
     *  msisdn: '15555555555'
     * });
     *
     * if (resp.errorCode) {
     *   console.log(`Error: ${resp.errorCodeLabel}`);
     * } else {
     *   console.log('Number cancled successfully');
     * }
     * ```
     */
    async cancelNumber(params) {
        const resp = await this.sendFormSubmitRequest(`${this.config.restHost}/number/cancel`, server_client_1.Client.transformers.snakeCaseObjectKeys(params));
        return {
            errorCode: `${resp.data['error-code']}`,
            errorCodeLabel: resp.data['error-code-label'],
        };
    }
    /**
     * Retrieves a list of available phone numbers based on the provided filter criteria.
     *
     * @param {NumbersSearchFilter} filter - The filter criteria for searching available numbers.
     * @return {Promise<NumbersAvailableList>} A promise that resolves to a list of available phone numbers or an error response.
     *
     * @example
     * Search for available numbers that can send SMS and make voice calls
     * ```ts
     * import { Country, Feature } from '@vonage/numbers';
     *
     * const resp = await numbersClient.getAvailableNumbers({
     *   country: Country.US,
     *   features: [Feature.SMS, Feature.VOICE],
     * });
     *
     * console.log(`There are ${resp.count} numbers available`);
     *
     * for (const number of resp.numbers) {
     *   console.log(number.msisdn);
     *   console.log(number.cost);
     *   console.log(number.type);
     * }
     * ```
     */
    async getAvailableNumbers(filter) {
        (0, lodash_omit_1.default)(server_client_1.Client.transformers.snakeCaseObjectKeys({
            ...filter,
            ...buildSearch(filter),
            country: filter.country,
        }), ['starts_with', 'contains', 'ends_with', 'search_pattern']);
        const resp = await this.sendGetRequest(`${this.config.restHost}/number/search`, {
            ...(filter.country ? { country: filter.country } : {}),
            ...(filter.type ? { type: filter.type } : {}),
            ...(filter.size ? { size: filter.size } : {}),
            ...(filter.index ? { index: filter.index } : {}),
            ...buildSearch(filter),
            ...(filter.features ? { features: sortFeatures(filter.features) } : {}),
        });
        return resp.data;
    }
    /**
     * Retrieves a list of owned phone numbers based on the provided filter criteria.
     *
     * @param {NumbersOwnedFilter} [filter] - The filter criteria for searching owned numbers.
     * @return {Promise<NumbersOwnedList>} A promise that resolves to a list of owned phone numbers or an error response.
     * @example
     * Search for owned numbers
     * ```ts
     * const resp = await numbersClient.getOwnedNumbers();
     * console.log(`There are ${resp.count} numbers owned`);
     * for (const number of resp.numbers) {
     *   console.log(number.msisdn);
     *   console.log(number.type);
     * }
     * ```
     */
    async getOwnedNumbers(filter) {
        if (!filter) {
            filter = {};
        }
        const resp = await this.sendGetRequest(`${this.config.restHost}/account/numbers`, server_client_1.Client.transformers.snakeCaseObjectKeys(filter));
        return resp.data;
    }
    /**
     * Updates the settings of a phone number.
     *
     * @param {NumbersUpdateParams} [params] - The parameters for updating a phone number.
     * @return {Promise<NumbersEmptyResponse>} A promise that resolves to an empty response or an error response.
     *
     * @example
     *
     * ```ts
     * const resp = await numbersClient.updateNumber({
     *   msisdn: '15555555555',
     *   voiceCallbackType: 'app',
     *   voiceCallbackValue: 'APPLICATION_ID',
     *   voiceStatusCallback: 'https://example.com/webhooks/voice',
     * });
     *
     * if (resp.errorCode) {
     *   console.log(`Error: ${resp.errorCodeLabel}`);
     * } else {
     *   console.log('Number bought successfully');
     * }
     * ```
     */
    async updateNumber(params) {
        const appId = params.applicationId || params.appId;
        delete params.applicationId;
        delete params.appId;
        const resp = await this.sendFormSubmitRequest(`${this.config.restHost}/number/update`, {
            ...(appId ? { app_id: appId } : {}),
            ...params,
        });
        return {
            errorCode: `${resp.data['error-code']}`,
            errorCodeLabel: resp.data['error-code-label'],
        };
    }
}
exports.Numbers = Numbers;
