"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const jwt_1 = require("@vonage/jwt");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const enums_1 = require("./enums");
const errors_1 = require("./errors");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('vonage:auth');
/**
 * Authentication class used for generating Authentication headers and query parameters.
 *
 * @remarks
 * This client is only available as a standalone client. It cannot be
 * instantiated from the server-sdk package.
 *
 * @example
 * Create a standard authentication object.
 *
 * ```ts
 * import { Auth } from '@vonage/auth';
 *
 * const auth = new Auth({
 *   apiKey: VONAGE_API_KEY,
 *   apiSecret: VONAGE_API_SECRET,
 *   applicationId: VONAGE_APPLICATION_ID,
 *   privateKey: VONAGE_APPLICATION_PRIVATE_KEY_PATH,
 * });
 * ```
 */
class Auth {
    constructor(opts) {
        /**
         * Generates query parameters for authentication, optionally merging with
         * provided parameters.
         *
         *
         * @param {T} [params] - Additional parameters to merge with the
         *     generated authentication query parameters.
         *
         * @return {Promise<AuthQueryParams>} - A promise that resolves
         *     with the merged authentication query parameters.
         *
         * @throws {MissingApiKeyError} - Thrown when the API key is missing.
         * @throws {MissingApiSecretError} - Thrown when the API secret is missing.
         * @throws {InvalidApiKeyError} - Thrown when the API key is not a valid string.
         * @throws {InvalidApiSecretError} - Thrown when the API secret is not a valid string.
         *
         * @example
         * Generate query parameters
         *
         * ```ts
         * const queryParams = await auth.getQueryParams();
         * ```
         *
         * @example
         * Generate query parameters and merge with additional Parameters
         *
         * ```ts
         * const queryParams = await auth.getQueryParams({
         *   to: '15555555555',
         *   from: '15555555556',
         *   text: 'Hello from Vonage SMS API'
         * });
         * ```
         */
        this.getQueryParams = async (params) => {
            if (!this.apiKey) {
                throw new errors_1.MissingApiKeyError();
            }
            if (!this.apiSecret) {
                throw new errors_1.MissingApiSecretError();
            }
            if (typeof this.apiKey !== 'string') {
                throw new errors_1.InvalidApiKeyError();
            }
            if (typeof this.apiSecret !== 'string') {
                throw new errors_1.InvalidApiSecretError();
            }
            return {
                ...params,
                api_key: this.apiKey,
                api_secret: this.apiSecret,
            };
        };
        /**
         * Generates a basic authentication header.
         *
         * @return {Promise<string>} - A promise that resolves with the
         *     generated basic authentication header.
         *
         * @throws {MissingApiKeyError} - Thrown when the API key is missing.
         * @throws {MissingApiSecretError} - Thrown when the API secret is missing.
         * @throws {InvalidApiKeyError} - Thrown when the API key is not a valid string.
         * @throws {InvalidApiSecretError} - Thrown when the API secret is not a valid string.
         *
         * @example
         * Generate a basic authentication headers
         *
         * ```ts
         * const basicAuthHeader = await auth.createBasicHeader();
         * ```
         */
        this.createBasicHeader = async () => {
            log('Creating basic auth header');
            if (!this.apiKey) {
                throw new errors_1.MissingApiKeyError();
            }
            if (!this.apiSecret) {
                throw new errors_1.MissingApiSecretError();
            }
            if (typeof this.apiKey !== 'string') {
                throw new errors_1.InvalidApiKeyError();
            }
            if (typeof this.apiSecret !== 'string') {
                throw new errors_1.InvalidApiSecretError();
            }
            const buf = Buffer.from(`${this.apiKey}:${this.apiSecret}`);
            return `Basic ${buf.toString('base64')}`;
        };
        /**
         * Generates a bearer authentication header.
         *
         * @return {Promise<string>} - A promise that resolves with the
         *     generated bearer authentication header.
         *
         * @example
         * Generate a bearer authentication headers
         *
         * ```ts
         * const bearerAuthHeader = await auth.createBearerHeader();
         * ```
         */
        this.createBearerHeader = async () => {
            log('Creating bearer header');
            return `Bearer ${(0, jwt_1.tokenGenerate)(this.applicationId || '', this.privateKey || '', this.jwtOptions)}`;
        };
        /**
         * Generates a signature hash for authentication, merging it with
         * provided parameters.
         *
         * @template T - Type of the parameters to merge with.
         * @param {T} params - Parameters to merge with the generated
         *     signature hash.
         * @return {Promise<AuthSignedParams>} - A promise that resolves
         *     with the merged signature hash and parameters.
         *
         * @throws {MissingApiKeyError} - Thrown when the API key is missing.
         * @throws {InvalidApiKeyError} - Thrown when the API key is not a valid string.
         * @throws {MissingSignatureError} - Thrown when the signature algorithm is missing.
         * @throws {MissingApiSecretError} - Thrown when the API secret is missing.
         * @throws {InvalidApiSecretError} - Thrown when the API secret is not a valid string.
         * @throws {InvalidSignatureAlgorithmError} - Thrown when an invalid signature algorithm is provided.
         *
         * @example
         * Generate a signature hash
         *
         * ```ts
         * const signatureHash = await auth.createSignatureHash({
         *   to: '15555555555',
         *   from: '15555555556',
         *   text: 'Hello from Vonage SMS API',
         *   timestamp: '1516878400',
         *   sig: 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6',
         * });
         * ```
         */
        this.createSignatureHash = async (params) => {
            log('Creating signature hash');
            if (!this.apiKey) {
                throw new errors_1.MissingApiKeyError();
            }
            if (typeof this.apiKey !== 'string') {
                throw new errors_1.InvalidApiKeyError();
            }
            if (!this.signature?.algorithm) {
                throw new errors_1.MissingSignatureError();
            }
            if (!this.signature?.secret) {
                throw new errors_1.MissingApiSecretError();
            }
            if (typeof this.signature?.secret !== 'string') {
                throw new errors_1.InvalidApiSecretError();
            }
            const returnParams = {
                ...params,
                api_key: this.apiKey,
            };
            // Add the current timestamp to the parameters list with the key
            // 'timestamp'. This should be an integer containing the number of seconds
            // since the epoch (UNIX time))
            if (!returnParams.timestamp) {
                returnParams.timestamp = Math.floor(Date.now() / 1000).toString();
            }
            const sortedParams = new URLSearchParams(returnParams);
            sortedParams.sort();
            const stringifiedParamsforSigning = sortedParams
                .toString()
                .replace(/(&|=)/gi, '_');
            switch (this.signature.algorithm) {
                case enums_1.AlgorithmTypes.md5hash:
                    returnParams.sig = (0, crypto_1.createHash)('md5')
                        .update(`${stringifiedParamsforSigning}${this.signature.secret}`)
                        .digest('hex');
                    break;
                case enums_1.AlgorithmTypes.md5hmac:
                    returnParams.sig = (0, crypto_1.createHmac)('md5', this.signature.secret)
                        .update(stringifiedParamsforSigning)
                        .digest('hex');
                    break;
                case enums_1.AlgorithmTypes.sha1hmac:
                    returnParams.sig = (0, crypto_1.createHmac)('sha1', this.signature.secret)
                        .update(stringifiedParamsforSigning)
                        .digest('hex');
                    break;
                case enums_1.AlgorithmTypes.sha256hmac:
                    returnParams.sig = (0, crypto_1.createHmac)('sha256', this.signature.secret)
                        .update(stringifiedParamsforSigning)
                        .digest('hex');
                    break;
                case enums_1.AlgorithmTypes.sha512hmac:
                    returnParams.sig = (0, crypto_1.createHmac)('sha512', this.signature.secret)
                        .update(stringifiedParamsforSigning)
                        .digest('hex');
                    break;
                default:
                    throw new errors_1.InvalidSignatureAlgorithmError();
            }
            return returnParams;
        };
        this.apiKey = opts?.apiKey || '';
        this.apiSecret = opts?.apiSecret || '';
        this.signature = opts?.signature || null;
        this.applicationId = opts?.applicationId || null;
        this.jwtOptions = opts?.jwtOptions || {};
        let privateKey = opts?.privateKey;
        if ((0, fs_1.existsSync)(opts?.privateKey)) {
            log('Reading private key file');
            privateKey = (0, fs_1.readFileSync)(opts?.privateKey).toString();
        }
        this.privateKey
            = privateKey instanceof Buffer ? privateKey.toString() : privateKey;
    }
}
exports.Auth = Auth;
